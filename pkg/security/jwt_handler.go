package security

import (
	"errors"
	"fmt"
	"github.com/golang-jwt/jwt/v4"
	"time"
)

type bearerTokenClaims struct {
	jwt.RegisteredClaims
	Roles []Role `json:"roles"`
}

func (btc *bearerTokenClaims) Valid() error {
	// The jwt.RegisteredClaims.Valid() method checks all date-time fields against time.Now(). This may fail in case
	// of clock skew. We are ignoring these checks here and perform them in our custom validator later on
	return nil
}

func (btc *bearerTokenClaims) toPayload() *JwtPayload {
	payload := &JwtPayload{}
	payload.UserId = btc.Subject
	payload.Roles = btc.Roles
	payload.Issuer = btc.Issuer
	payload.Audience = btc.Audience
	if btc.ExpiresAt != nil {
		payload.ExpiresAt = btc.ExpiresAt.Time
	}
	if btc.NotBefore != nil {
		payload.NotBefore = btc.NotBefore.Time
	}
	if btc.IssuedAt != nil {
		payload.IssuedAt = btc.IssuedAt.Time
	}
	return payload
}

var signingMethod = jwt.SigningMethodHS256

type JwtHandler struct {
	parser *jwt.Parser
	
	// Issuer of the token (authority). Will be set in generated token and checked in parsed token
	// Must be set to a non-empty value to generate a valid token
	Issuer string
	
	// AudienceExpected defines which audience must be present in parsed token during validation
	AudienceExpected string
	
	// AudienceGenerated defines the audience claim value in generated tokens
	// Must be set to a non-empty array to generate a valid token
	AudienceGenerated []string
	
	// TokenTtl defines expiration time for generated tokens
	TokenTtl time.Duration
	
	// TODO: implement expiration validation with clock skew
	//ClockSkew time.Duration
	
	// SigningKey defines the key to be used for signing generated tokens and verifying parsed tokens
	SigningKey []byte
}

func NewJwtHandler(
	issuer string,
	expAudience string,
	targetAudience []string,
	tokenTTL time.Duration,
	signingKey []byte,
) *JwtHandler {
	return &JwtHandler{
		parser:            jwt.NewParser(jwt.WithValidMethods([]string{signingMethod.Alg()})),
		Issuer:            issuer,
		AudienceExpected:  expAudience,
		AudienceGenerated: targetAudience,
		TokenTtl:          tokenTTL,
		SigningKey:        signingKey,
	}
}

func (jh *JwtHandler) Generate(principal *UserPrincipal) (string, error) {
	btc := jh.generateClaims(principal)
	return jh.generateSignedString(btc)
}

func (jh *JwtHandler) generateClaims(principal *UserPrincipal) *bearerTokenClaims {
	var btc bearerTokenClaims
	btc.Issuer = jh.Issuer
	btc.Audience = jh.AudienceGenerated
	btc.Subject = principal.UserId
	btc.Roles = principal.Roles
	
	now := time.Now()
	btc.IssuedAt = jwt.NewNumericDate(now)
	btc.NotBefore = btc.IssuedAt
	exp := now.Add(jh.TokenTtl)
	btc.ExpiresAt = jwt.NewNumericDate(exp)
	
	return &btc
}

func (jh *JwtHandler) generateSignedString(btc *bearerTokenClaims) (string, error) {
	token := jwt.NewWithClaims(signingMethod, btc)
	return token.SignedString(jh.SigningKey)
}

func (jh *JwtHandler) keyFunc(token *jwt.Token) (interface{}, error) {
	if token.Method != signingMethod {
		return nil, errors.New("unexpected signing method")
	}
	return jh.SigningKey, nil
}

// Parse parses and validates a JWT token string
func (jh *JwtHandler) Parse(tokenString string) (*JwtPayload, error) {
	var btc bearerTokenClaims
	_, err := jh.parser.ParseWithClaims(tokenString, &btc, jh.keyFunc)
	if err != nil {
		return nil, err
	}
	payload := btc.toPayload()
	return payload, jh.validateClaims(&btc)
}

// ParseWithoutSignature parses and validates a JWT token string, while ignoring signature
// May be used by client services which reuse tokens generated by a remote authority
// Signature must be validated by other means (e.g. by passing the token to the authority via an endpoint)
func (jh *JwtHandler) ParseWithoutSignature(tokenString string) (*JwtPayload, error) {
	var btc bearerTokenClaims
	_, _, err := jh.parser.ParseUnverified(tokenString, &btc)
	if err != nil {
		return nil, err
	}
	payload := btc.toPayload()
	return payload, jh.validateClaims(&btc)
}

func (jh *JwtHandler) validateClaims(btc *bearerTokenClaims) error {
	if err := jh.validateTimestamps(btc); err != nil {
		return err
	}
	if !btc.VerifyIssuer(jh.Issuer, true) {
		return jwt.NewValidationError(jwt.ErrTokenInvalidIssuer.Error(), jwt.ValidationErrorIssuer)
	}
	if !btc.VerifyAudience(jh.AudienceExpected, true) {
		return jwt.NewValidationError(jwt.ErrTokenInvalidAudience.Error(), jwt.ValidationErrorAudience)
	}
	return nil
}

// validateTimestamps is based on jwt.RegisteredClaims.Valid()
// TODO: clock skew
func (jh *JwtHandler) validateTimestamps(btc *bearerTokenClaims) error {
	vErr := new(jwt.ValidationError)
	now := jwt.TimeFunc()
	
	if !btc.VerifyExpiresAt(now, true) {
		if btc.ExpiresAt != nil {
			delta := now.Sub(btc.ExpiresAt.Time)
			vErr.Inner = fmt.Errorf("%s by %s", jwt.ErrTokenExpired, delta)
		} else {
			vErr.Inner = jwt.ErrTokenExpired
		}
		
		vErr.Errors |= jwt.ValidationErrorExpired
	}
	
	if !btc.VerifyIssuedAt(now, true) {
		vErr.Inner = jwt.ErrTokenUsedBeforeIssued
		vErr.Errors |= jwt.ValidationErrorIssuedAt
	}
	
	if !btc.VerifyNotBefore(now, true) {
		vErr.Inner = jwt.ErrTokenNotValidYet
		vErr.Errors |= jwt.ValidationErrorNotValidYet
	}
	
	if vErr.Errors == 0 {
		return nil
	}
	
	return vErr
}

type JwtPayload struct {
	UserPrincipal
	
	// Issuer of the token (authority)
	Issuer string
	
	// Audience of the token
	Audience []string
	
	// ExpiresAt - the Expiration Time claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4
	ExpiresAt time.Time
	
	// NotBefore - the Not Before claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.5
	NotBefore time.Time
	
	// IssuedAt - the Issued At claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.6
	IssuedAt time.Time
}
